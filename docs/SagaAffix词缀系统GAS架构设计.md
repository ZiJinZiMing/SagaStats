# SagaAffixè¯ç¼€ç³»ç»ŸGASæ¶æ„è®¾è®¡

## æ–‡æ¡£ä¿¡æ¯
- **æ–‡æ¡£æ ‡é¢˜**: SagaAffixè¯ç¼€ç³»ç»ŸGASæ¶æ„è®¾è®¡
- **åˆ›å»ºæ—¥æœŸ**: 2025-07-17
- **ç‰ˆæœ¬**: v3.0 - åŠ¨ä½œæ¸¸æˆç‰¹åŒ–ç‰ˆ
- **è®¾è®¡æ–¹æ¡ˆ**: é¢å‘åŠ¨ä½œæ¸¸æˆä¼˜åŒ–çš„çº¯GASæ¶æ„
- **æ–‡æ¡£ä½œè€…**: ZhangJinming
- **åŸºäºæ–‡æ¡£**: åŠ¨ä½œæ¸¸æˆè¯ç¼€ç³»ç»Ÿè®¾è®¡æŒ‡å—.md

---

## ç›®å½•
1. [v3.0ç‰ˆæœ¬å‡çº§æ¦‚è¿°](#v30ç‰ˆæœ¬å‡çº§æ¦‚è¿°)
2. [åŠ¨ä½œæ¸¸æˆç‰¹åŒ–æ¶æ„](#åŠ¨ä½œæ¸¸æˆç‰¹åŒ–æ¶æ„)
3. [å®æ—¶æ€§èƒ½ä¼˜åŒ–è®¾è®¡](#å®æ—¶æ€§èƒ½ä¼˜åŒ–è®¾è®¡)
4. [ç©å®¶ä½“éªŒå¢å¼ºç³»ç»Ÿ](#ç©å®¶ä½“éªŒå¢å¼ºç³»ç»Ÿ)
5. [æ™ºèƒ½å¹³è¡¡ä¸å¤æ‚åº¦ç®¡ç†](#æ™ºèƒ½å¹³è¡¡ä¸å¤æ‚åº¦ç®¡ç†)
6. [ç¤¾åŒºä¸åˆ›ä½œæ”¯æŒ](#ç¤¾åŒºä¸åˆ›ä½œæ”¯æŒ)
7. [æ ¸å¿ƒç±»è®¾è®¡ä¼˜åŒ–](#æ ¸å¿ƒç±»è®¾è®¡ä¼˜åŒ–)
8. [åŠ¨ä½œæ¸¸æˆæµç¨‹ä¼˜åŒ–](#åŠ¨ä½œæ¸¸æˆæµç¨‹ä¼˜åŒ–)
9. [ç½‘ç»œæ¶æ„å¢å¼º](#ç½‘ç»œæ¶æ„å¢å¼º)
10. [å®æ–½è·¯çº¿å›¾æ›´æ–°](#å®æ–½è·¯çº¿å›¾æ›´æ–°)

---

## v3.0ç‰ˆæœ¬å‡çº§æ¦‚è¿°

### ğŸ® åŠ¨ä½œæ¸¸æˆç‰¹åŒ–å‡çº§

åŸºäºã€ŠåŠ¨ä½œæ¸¸æˆè¯ç¼€ç³»ç»Ÿè®¾è®¡æŒ‡å—ã€‹çš„æ·±åº¦åˆ†æï¼Œv3.0ç‰ˆæœ¬ä¸“é—¨é’ˆå¯¹åŠ¨ä½œæ¸¸æˆçš„ç‰¹æ®Šéœ€æ±‚è¿›è¡Œäº†å…¨é¢ä¼˜åŒ–ï¼š

#### æ ¸å¿ƒå‡çº§ç‚¹
```mermaid
mindmap
  root((v3.0å‡çº§))
    å®æ—¶æ€§èƒ½
      æ¯«ç§’çº§å“åº”
      é¢„æµ‹ä¼˜åŒ–
      æ‰¹å¤„ç†æ”¹è¿›
      å†…å­˜æ± åŒ–
    ç©å®¶ä½“éªŒ
      å³æ—¶åé¦ˆ
      è§†è§‰çˆ†å‘
      éŸ³æ•ˆåè°ƒ
      è§¦è§‰åé¦ˆ
    æ™ºèƒ½ç³»ç»Ÿ
      åŠ¨æ€å¹³è¡¡
      å¤æ‚åº¦ç®¡ç†
      AIæ¨è
      è‡ªé€‚åº”éš¾åº¦
    ç¤¾åŒºåŠŸèƒ½
      æ„å»ºåˆ†äº«
      åˆ›ä½œå·¥å…·
      æŒ‘æˆ˜ç³»ç»Ÿ
      ç¤¾åŒºç»æµ
    æ‰©å±•èƒ½åŠ›
      æ¨¡å—åŒ–ç»„ä»¶
      æ’ä»¶æ¥å£
      è‡ªå®šä¹‰è§„åˆ™
      æ•°æ®é©±åŠ¨
```

#### è®¾è®¡ç†å¿µè¿›åŒ–
```
v2.0: çº¯GASæ¶æ„ï¼Œå®Œç¾æŠ€æœ¯é›†æˆ
         â†“
v3.0: åŠ¨ä½œæ¸¸æˆä¸“ç”¨ï¼Œæè‡´ç©å®¶ä½“éªŒ
```

---

## åŠ¨ä½œæ¸¸æˆç‰¹åŒ–æ¶æ„

### 1. å“åº”å¼è¯ç¼€ç³»ç»Ÿæ¶æ„

```mermaid
graph TB
    subgraph "Real-time Layer å®æ—¶å±‚"
        RTProcessor[å®æ—¶å¤„ç†å™¨]
        Predictor[æ•ˆæœé¢„æµ‹å™¨]
        FastCache[å¿«é€Ÿç¼“å­˜]
        InstantFeedback[å³æ—¶åé¦ˆ]
    end
    
    subgraph "Action Game Layer åŠ¨ä½œæ¸¸æˆå±‚"
        CombatIntegration[æˆ˜æ–—é›†æˆ]
        MovementEnhancer[ç§»åŠ¨å¢å¼º]
        SkillAmplifier[æŠ€èƒ½æ”¾å¤§å™¨]
        ComboSystem[è¿å‡»ç³»ç»Ÿ]
    end
    
    subgraph "Player Experience Layer ç©å®¶ä½“éªŒå±‚"
        VFXManager[ç‰¹æ•ˆç®¡ç†å™¨]
        AudioReactor[éŸ³é¢‘ååº”å™¨]
        HapticController[è§¦è§‰æ§åˆ¶å™¨]
        UIAnimator[UIåŠ¨ç”»å™¨]
    end
    
    subgraph "GAS Core Layer GASæ ¸å¿ƒå±‚"
        ASC[AbilitySystemComponent]
        AttributeSets[AttributeSets]
        GameplayEffects[GameplayEffects]
        GameplayAbilities[GameplayAbilities]
    end
    
    subgraph "Intelligence Layer æ™ºèƒ½å±‚"
        BalanceManager[å¹³è¡¡ç®¡ç†å™¨]
        ComplexityController[å¤æ‚åº¦æ§åˆ¶å™¨]
        AIRecommender[AIæ¨èå™¨]
        AdaptiveDifficulty[è‡ªé€‚åº”éš¾åº¦]
    end
    
    %% è¿æ¥å…³ç³»
    RTProcessor --> CombatIntegration
    Predictor --> MovementEnhancer
    FastCache --> SkillAmplifier
    InstantFeedback --> ComboSystem
    
    CombatIntegration --> VFXManager
    MovementEnhancer --> AudioReactor
    SkillAmplifier --> HapticController
    ComboSystem --> UIAnimator
    
    VFXManager --> ASC
    AudioReactor --> AttributeSets
    HapticController --> GameplayEffects
    UIAnimator --> GameplayAbilities
    
    ASC --> BalanceManager
    AttributeSets --> ComplexityController
    GameplayEffects --> AIRecommender
    GameplayAbilities --> AdaptiveDifficulty
```

### 2. åŠ¨ä½œæ¸¸æˆè¯ç¼€åˆ†ç±»ç³»ç»Ÿ

```cpp
/**
 * åŠ¨ä½œæ¸¸æˆä¸“ç”¨è¯ç¼€åˆ†ç±»
 * Action game specific affix categories
 */
UENUM(BlueprintType)
enum class ESagaActionAffixCategory : uint8
{
    // === æ ¸å¿ƒåŠ¨ä½œç±» ===
    Combat          UMETA(DisplayName = "æˆ˜æ–—å¢å¼º"),     // ç›´æ¥å½±å“æˆ˜æ–—æ•ˆæœ
    Movement        UMETA(DisplayName = "ç§»åŠ¨å¼ºåŒ–"),     // å½±å“è§’è‰²ç§»åŠ¨èƒ½åŠ›
    Defensive       UMETA(DisplayName = "é˜²å¾¡æå‡"),     // ç”Ÿå­˜å’Œé˜²æŠ¤èƒ½åŠ›
    
    // === æŠ€èƒ½æ‰©å±•ç±» ===
    SkillModifier   UMETA(DisplayName = "æŠ€èƒ½æ”¹é€ "),     // æ”¹å˜ç°æœ‰æŠ€èƒ½
    ComboEnhancer   UMETA(DisplayName = "è¿å‡»å¢å¼º"),     // è¿å‡»å’Œç»„åˆæŠ€
    ElementalFusion UMETA(DisplayName = "å…ƒç´ èåˆ"),     // å…ƒç´ æ•ˆæœç»„åˆ
    
    // === æˆ˜æœ¯ç­–ç•¥ç±» ===
    TimeManipulation UMETA(DisplayName = "æ—¶é—´æ“æ§"),    // æ—¶é—´ç›¸å…³æ•ˆæœ
    SpaceControl     UMETA(DisplayName = "ç©ºé—´æ§åˆ¶"),    // ç©ºé—´å’Œä½ç½®
    ResourceManager  UMETA(DisplayName = "èµ„æºç®¡ç†"),    // èƒ½é‡ã€ç”Ÿå‘½ç­‰èµ„æº
    
    // === ç¯å¢ƒäº¤äº’ç±» ===
    Environmental   UMETA(DisplayName = "ç¯å¢ƒäº¤äº’"),     // ä¸ç¯å¢ƒçš„äº’åŠ¨
    WeatherControl  UMETA(DisplayName = "å¤©æ°”æ§åˆ¶"),     // å¤©æ°”å’Œæ°›å›´
    TerrainShaper   UMETA(DisplayName = "åœ°å½¢å¡‘é€ "),     // åœ°å½¢æ”¹å˜
    
    // === ç¤¾äº¤åä½œç±» ===
    TeamSynergy     UMETA(DisplayName = "å›¢é˜ŸååŒ"),     // å¤šäººåä½œ
    Leadership      UMETA(DisplayName = "é¢†å¯¼èƒ½åŠ›"),     // å›¢é˜Ÿé¢†å¯¼
    Support         UMETA(DisplayName = "æ”¯æ´è¾…åŠ©"),     // è¾…åŠ©é˜Ÿå‹
    
    // === åˆ›æ–°å®éªŒç±» ===
    Experimental    UMETA(DisplayName = "å®éªŒæ€§"),       // åˆ›æ–°å’Œå®éªŒ
    Metamorphosis   UMETA(DisplayName = "å½¢æ€å˜åŒ–"),     // å½¢æ€è½¬æ¢
    Reality         UMETA(DisplayName = "ç°å®æ‰­æ›²")      // çªç ´å¸¸è§„
};
```

### 3. åŠ¨ä½œæ¸¸æˆå“åº”ä¼˜å…ˆçº§ç³»ç»Ÿ

```cpp
/**
 * åŠ¨ä½œæ¸¸æˆå“åº”ä¼˜å…ˆçº§ç®¡ç†å™¨
 * Action game response priority manager
 */
UCLASS()
class SAGASTATS_API USagaActionGameResponseManager : public UObject
{
    GENERATED_BODY()

public:
    // å“åº”ä¼˜å…ˆçº§ç­‰çº§
    UENUM(BlueprintType)
    enum class EResponsePriority : uint8
    {
        Critical    = 0,    // å³æ­»æ”»å‡»ã€å®Œç¾é—ªé¿ç­‰
        High        = 1,    // é‡è¦æ”»å‡»ã€æŠ€èƒ½é‡Šæ”¾ç­‰
        Medium      = 2,    // ä¸€èˆ¬æ”»å‡»ã€ç§»åŠ¨ç­‰
        Low         = 3,    // ç¯å¢ƒæ•ˆæœã€UIæ›´æ–°ç­‰
        Background  = 4     // ç»Ÿè®¡æ›´æ–°ã€ç¼“å­˜æ¸…ç†ç­‰
    };
    
    struct FActionGameResponse {
        EResponsePriority Priority;
        float MaxLatency;       // æœ€å¤§å…è®¸å»¶è¿Ÿ(æ¯«ç§’)
        bool bRequiresPrediction; // æ˜¯å¦éœ€è¦é¢„æµ‹
        bool bRequiresFeedback;   // æ˜¯å¦éœ€è¦åé¦ˆ
        FString Description;
    };
    
    // é¢„å®šä¹‰çš„å“åº”é…ç½®
    TMap<FGameplayTag, FActionGameResponse> ResponseConfigs = {
        {
            FGameplayTag::RequestGameplayTag("Affix.Combat.CriticalHit"),
            {EResponsePriority::Critical, 16.0f, true, true, "æš´å‡»æ•ˆæœ"}
        },
        {
            FGameplayTag::RequestGameplayTag("Affix.Movement.Dash"),
            {EResponsePriority::High, 33.0f, true, true, "å†²åˆºç§»åŠ¨"}
        },
        {
            FGameplayTag::RequestGameplayTag("Affix.Defense.Shield"),
            {EResponsePriority::High, 50.0f, false, true, "æŠ¤ç›¾æ¿€æ´»"}
        },
        {
            FGameplayTag::RequestGameplayTag("Affix.Environment.Weather"),
            {EResponsePriority::Low, 200.0f, false, false, "å¤©æ°”å˜åŒ–"}
        }
    };
    
    /**
     * æ ¹æ®ä¼˜å…ˆçº§å¤„ç†è¯ç¼€å“åº”
     */
    UFUNCTION(BlueprintCallable)
    void ProcessAffixResponse(const FGameplayTag& AffixTag, const FGameplayEventData& EventData);
    
    /**
     * é¢„æµ‹å¹¶åº”ç”¨é«˜ä¼˜å…ˆçº§æ•ˆæœ
     */
    UFUNCTION(BlueprintCallable)
    void PredictCriticalResponse(const FGameplayTag& AffixTag, AActor* TargetActor);
};
```

---

## å®æ—¶æ€§èƒ½ä¼˜åŒ–è®¾è®¡

### 1. æ¯«ç§’çº§å“åº”æ¶æ„

```mermaid
sequenceDiagram
    participant Player as ç©å®¶è¾“å…¥
    participant Predictor as æ•ˆæœé¢„æµ‹å™¨
    participant Cache as å¿«é€Ÿç¼“å­˜
    participant ASC as GASæ ¸å¿ƒ
    participant Feedback as åé¦ˆç³»ç»Ÿ
    
    Note over Player,Feedback: 16msç›®æ ‡å“åº”æ—¶é—´
    
    Player->>Predictor: æŠ€èƒ½è§¦å‘ (0ms)
    Predictor->>Cache: æŸ¥è¯¢é¢„è®¡ç®—ç»“æœ (1ms)
    Cache-->>Predictor: è¿”å›é¢„æµ‹æ•°æ® (2ms)
    Predictor->>Feedback: ç«‹å³è§†è§‰åé¦ˆ (4ms)
    
    Note over Predictor: å¹¶è¡Œå¤„ç†
    Predictor->>ASC: åå°éªŒè¯è®¡ç®— (5ms)
    ASC->>ASC: ç²¾ç¡®è®¡ç®—å’ŒéªŒè¯ (15ms)
    ASC-->>Predictor: éªŒè¯ç»“æœ (16ms)
    
    alt é¢„æµ‹æ­£ç¡®
        Predictor->>Feedback: ç¡®è®¤æ•ˆæœ (17ms)
    else é¢„æµ‹é”™è¯¯
        Predictor->>Feedback: ä¿®æ­£æ•ˆæœ (18ms)
        Feedback->>Feedback: å¹³æ»‘è¿‡æ¸¡ (35ms)
    end
```

### 2. æ™ºèƒ½é¢„è®¡ç®—ç³»ç»Ÿ

```cpp
/**
 * æ™ºèƒ½é¢„è®¡ç®—ç¼“å­˜ç³»ç»Ÿ
 * Smart pre-computation cache system
 */
UCLASS()
class SAGASTATS_API USagaAffixPreComputeCache : public UObject
{
    GENERATED_BODY()

public:
    // é¢„è®¡ç®—æ•°æ®ç»“æ„
    USTRUCT()
    struct FPreComputedAffixData {
        FGameplayTag AffixTag;
        TMap<int32, float> LevelToMagnitude;    // ç­‰çº§åˆ°æ•°å€¼çš„æ˜ å°„
        TMap<FGameplayTag, float> SynergyBonus; // ååŒæ•ˆæœåŠ æˆ
        float BaseExecutionTime;                // åŸºç¡€æ‰§è¡Œæ—¶é—´
        TArray<FGameplayTag> PredictedEffects;  // é¢„æµ‹çš„è¿é”æ•ˆæœ
        
        // ç¼“å­˜æœ‰æ•ˆæ€§
        float CacheTimestamp;
        bool bIsValid;
    };
    
    // ç¼“å­˜å­˜å‚¨
    UPROPERTY()
    TMap<FGameplayTag, FPreComputedAffixData> PreComputedData;
    
    // çƒ­ç‚¹æ•°æ®å¿«é€Ÿè®¿é—®
    UPROPERTY()
    TMap<FGameplayTag, float> HotDataCache;
    
    /**
     * é¢„è®¡ç®—å¸¸ç”¨è¯ç¼€ç»„åˆ
     */
    UFUNCTION(BlueprintCallable)
    void PreComputeCommonCombinations();
    
    /**
     * å®æ—¶é¢„æµ‹è¯ç¼€æ•ˆæœ
     */
    UFUNCTION(BlueprintCallable)
    bool PredictAffixEffect(const FGameplayTag& AffixTag, float Level, 
                           AActor* Target, FPreComputedAffixData& OutPrediction);
    
    /**
     * å¼‚æ­¥æ›´æ–°é¢„è®¡ç®—æ•°æ®
     */
    UFUNCTION(BlueprintCallable)
    void AsyncUpdatePreComputedData(const TArray<FGameplayTag>& AffixTags);
    
private:
    // é¢„è®¡ç®—ä»»åŠ¡é˜Ÿåˆ—
    TQueue<FGameplayTag> PreComputeQueue;
    
    // å¼‚æ­¥ä»»åŠ¡å¥æŸ„
    TFuture<void> AsyncComputeTask;
    
    /**
     * åå°é¢„è®¡ç®—çº¿ç¨‹
     */
    void BackgroundPreComputeThread();
    
    /**
     * è®¡ç®—è¯ç¼€æ•°å€¼
     */
    float ComputeAffixMagnitude(const FGameplayTag& AffixTag, float Level, 
                               const TArray<FGameplayTag>& ActiveAffixes);
};
```

### 3. å†…å­˜æ± åŒ–ç®¡ç†

```cpp
/**
 * è¯ç¼€å¯¹è±¡æ± ç®¡ç†å™¨
 * Affix object pool manager
 */
UCLASS()
class SAGASTATS_API USagaAffixObjectPool : public UGameInstanceSubsystem
{
    GENERATED_BODY()

public:
    // å¯¹è±¡æ± é…ç½®
    USTRUCT()
    struct FObjectPoolConfig {
        int32 InitialSize = 50;      // åˆå§‹å¤§å°
        int32 MaxSize = 200;         // æœ€å¤§å¤§å°
        int32 GrowthSize = 25;       // å¢é•¿å¤§å°
        float ShrinkThreshold = 0.3f; // æ”¶ç¼©é˜ˆå€¼
        float ShrinkInterval = 30.0f; // æ”¶ç¼©æ£€æŸ¥é—´éš”
    };
    
    // ä¸åŒç±»å‹çš„å¯¹è±¡æ± 
    UPROPERTY()
    TMap<TSubclassOf<USagaAffixInstanceAbility>, TArray<USagaAffixInstanceAbility*>> AffixAbilityPools;
    
    UPROPERTY()
    TMap<TSubclassOf<UGameplayEffect>, TArray<UGameplayEffect*>> GameplayEffectPools;
    
    UPROPERTY()
    TArray<FSagaActiveAffixInfo*> AffixInfoPool;
    
    /**
     * è·å–è¯ç¼€å®ä¾‹èƒ½åŠ›
     */
    UFUNCTION(BlueprintCallable)
    USagaAffixInstanceAbility* AcquireAffixAbility(TSubclassOf<USagaAffixInstanceAbility> AbilityClass);
    
    /**
     * å½’è¿˜è¯ç¼€å®ä¾‹èƒ½åŠ›
     */
    UFUNCTION(BlueprintCallable)
    void ReleaseAffixAbility(USagaAffixInstanceAbility* Ability);
    
    /**
     * è·å–GameplayEffect
     */
    UFUNCTION(BlueprintCallable)
    UGameplayEffect* AcquireGameplayEffect(TSubclassOf<UGameplayEffect> EffectClass);
    
    /**
     * å½’è¿˜GameplayEffect
     */
    UFUNCTION(BlueprintCallable)
    void ReleaseGameplayEffect(UGameplayEffect* Effect);
    
    /**
     * æ™ºèƒ½æ¸…ç†æœªä½¿ç”¨çš„å¯¹è±¡
     */
    UFUNCTION(BlueprintCallable)
    void SmartCleanup();
    
private:
    // æ± åŒ–é…ç½®
    UPROPERTY(EditDefaultsOnly)
    FObjectPoolConfig PoolConfig;
    
    // æ¸…ç†å®šæ—¶å™¨
    FTimerHandle CleanupTimerHandle;
    
    /**
     * æ‰©å±•å¯¹è±¡æ± 
     */
    template<typename T>
    void ExpandPool(TArray<T*>& Pool, TSubclassOf<T> Class, int32 Count);
    
    /**
     * æ”¶ç¼©å¯¹è±¡æ± 
     */
    template<typename T>
    void ShrinkPool(TArray<T*>& Pool, float Threshold);
};
```

---

## ç©å®¶ä½“éªŒå¢å¼ºç³»ç»Ÿ

### 1. å¤šå±‚æ¬¡åé¦ˆç³»ç»Ÿ

```mermaid
graph TB
    subgraph "Instant Feedback å³æ—¶åé¦ˆ (0-16ms)"
        VisualPreview[è§†è§‰é¢„è§ˆ]
        SoundPreview[éŸ³æ•ˆé¢„è§ˆ]
        HapticPulse[è§¦è§‰è„‰å†²]
        UIHighlight[UIé«˜äº®]
    end
    
    subgraph "Confirmation Feedback ç¡®è®¤åé¦ˆ (16-100ms)"
        ParticleEffect[ç²’å­ç‰¹æ•ˆ]
        ScreenShake[å±å¹•éœ‡åŠ¨]
        AudioStinger[éŸ³é¢‘æ ‡è¯†]
        NumberPopup[æ•°å­—å¼¹å‡º]
    end
    
    subgraph "Enhancement Feedback å¢å¼ºåé¦ˆ (100-500ms)"
        FullVFX[å®Œæ•´ç‰¹æ•ˆ]
        MusicLayer[éŸ³ä¹å±‚æ¬¡]
        CameraEffect[é•œå¤´æ•ˆæœ]
        EnvironmentReaction[ç¯å¢ƒååº”]
    end
    
    subgraph "Contextual Feedback æƒ…å¢ƒåé¦ˆ (500ms+)"
        WorldChange[ä¸–ç•Œå˜åŒ–]
        NPCReaction[NPCååº”]
        StoryProgression[å‰§æƒ…æ¨è¿›]
        SocialSharing[ç¤¾äº¤åˆ†äº«]
    end
    
    %% æ—¶é—´æµç¨‹
    VisualPreview --> ParticleEffect
    SoundPreview --> AudioStinger
    HapticPulse --> ScreenShake
    UIHighlight --> NumberPopup
    
    ParticleEffect --> FullVFX
    AudioStinger --> MusicLayer
    ScreenShake --> CameraEffect
    NumberPopup --> EnvironmentReaction
    
    FullVFX --> WorldChange
    MusicLayer --> NPCReaction
    CameraEffect --> StoryProgression
    EnvironmentReaction --> SocialSharing
```

### 2. æš´çˆ½æ—¶åˆ»è®¾è®¡ç³»ç»Ÿ

```cpp
/**
 * æš´çˆ½æ—¶åˆ»ç®¡ç†å™¨
 * Epic moment manager
 */
UCLASS()
class SAGASTATS_API USagaEpicMomentManager : public UObject
{
    GENERATED_BODY()

public:
    // æš´çˆ½æ—¶åˆ»ç±»å‹
    UENUM(BlueprintType)
    enum class EEpicMomentType : uint8
    {
        AffixCombo          UMETA(DisplayName = "è¯ç¼€è¿å‡»"),
        PowerOverload       UMETA(DisplayName = "åŠ›é‡è¿‡è½½"),
        SynergyExplosion    UMETA(DisplayName = "ååŒçˆ†å‘"),
        PerfectTiming       UMETA(DisplayName = "å®Œç¾æ—¶æœº"),
        ChainReaction       UMETA(DisplayName = "è¿é”ååº”"),
        UltimateCombo       UMETA(DisplayName = "ç»ˆæè¿å‡»")
    };
    
    // æš´çˆ½æ—¶åˆ»é…ç½®
    USTRUCT()
    struct FEpicMomentConfig {
        EEpicMomentType Type;
        float TriggerThreshold;     // è§¦å‘é˜ˆå€¼
        float IntensityMultiplier;  // å¼ºåº¦å€æ•°
        float Duration;             // æŒç»­æ—¶é—´
        FGameplayTag RequiredTags;  // éœ€è¦çš„æ ‡ç­¾
        
        // è§†è§‰æ•ˆæœ
        TSubclassOf<AActor> VFXClass;
        FLinearColor ScreenTint;
        float CameraShakeScale;
        
        // éŸ³é¢‘æ•ˆæœ
        USoundBase* TriggerSound;
        USoundBase* AmbientSound;
        float MusicIntensityBoost;
        
        // æ¸¸æˆæœºåˆ¶
        float TimeDialationFactor;
        float DamageMultiplier;
        bool bGrantTemporaryAbility;
    };
    
    // é¢„å®šä¹‰çš„æš´çˆ½æ—¶åˆ»
    UPROPERTY(EditDefaultsOnly)
    TArray<FEpicMomentConfig> EpicMomentConfigs;
    
    /**
     * æ£€æµ‹å¹¶è§¦å‘æš´çˆ½æ—¶åˆ»
     */
    UFUNCTION(BlueprintCallable)
    bool TryTriggerEpicMoment(AActor* Actor, const TArray<FGameplayTag>& AffixTags, 
                             float PowerLevel, const FGameplayEventData& EventData);
    
    /**
     * è®¡ç®—æš´çˆ½æ—¶åˆ»å¼ºåº¦
     */
    UFUNCTION(BlueprintPure)
    float CalculateEpicIntensity(const TArray<FGameplayTag>& AffixTags, float PowerLevel);
    
    /**
     * åº”ç”¨æš´çˆ½æ—¶åˆ»æ•ˆæœ
     */
    UFUNCTION(BlueprintCallable)
    void ApplyEpicMomentEffects(AActor* Actor, const FEpicMomentConfig& Config, float Intensity);
    
private:
    // å½“å‰æ´»è·ƒçš„æš´çˆ½æ—¶åˆ»
    UPROPERTY()
    TMap<AActor*, FEpicMomentConfig> ActiveEpicMoments;
    
    // å†·å´æ—¶é—´ç®¡ç†
    UPROPERTY()
    TMap<EEpicMomentType, float> EpicMomentCooldowns;
    
    /**
     * åˆ†æè¯ç¼€ç»„åˆçš„æš´çˆ½æ½œåŠ›
     */
    float AnalyzeEpicPotential(const TArray<FGameplayTag>& AffixTags);
    
    /**
     * æ£€æŸ¥æš´çˆ½æ—¶åˆ»å†·å´
     */
    bool IsEpicMomentReady(EEpicMomentType Type);
};
```

### 3. åŠ¨æ€è§†è§‰æ•ˆæœç³»ç»Ÿ

```cpp
/**
 * åŠ¨æ€è¯ç¼€è§†è§‰æ•ˆæœç®¡ç†å™¨
 * Dynamic affix visual effects manager
 */
UCLASS()
class SAGASTATS_API USagaDynamicVFXManager : public UObject
{
    GENERATED_BODY()

public:
    // è§†è§‰æ•ˆæœå±‚æ¬¡
    UENUM(BlueprintType)
    enum class EVFXLayer : uint8
    {
        Background      = 0,    // èƒŒæ™¯æ•ˆæœ
        CharacterAura   = 1,    // è§’è‰²å…‰ç¯
        WeaponEffect    = 2,    // æ­¦å™¨ç‰¹æ•ˆ
        AbilityEffect   = 3,    // æŠ€èƒ½ç‰¹æ•ˆ
        ImpactEffect    = 4,    // å†²å‡»ç‰¹æ•ˆ
        ScreenEffect    = 5     // å±å¹•æ•ˆæœ
    };
    
    // è§†è§‰æ•ˆæœé…ç½®
    USTRUCT()
    struct FDynamicVFXConfig {
        FGameplayTag AffixTag;
        EVFXLayer Layer;
        TSubclassOf<UNiagaraComponent> VFXClass;
        
        // å¼ºåº¦è®¾ç½®
        float BaseIntensity = 1.0f;
        float MaxIntensity = 3.0f;
        FVector2D IntensityRange = FVector2D(0.5f, 2.0f);
        
        // é¢œè‰²è®¾ç½®
        FLinearColor BaseColor = FLinearColor::White;
        TArray<FLinearColor> RarityColors;
        
        // è¡Œä¸ºè®¾ç½®
        bool bStacksIntensity = true;
        bool bFadesOverTime = false;
        float FadeDuration = 5.0f;
        
        // ååŒæ•ˆæœ
        TMap<FGameplayTag, float> SynergyIntensityBonus;
        TMap<FGameplayTag, FLinearColor> SynergyColorShift;
    };
    
    /**
     * æ³¨å†Œè¯ç¼€è§†è§‰æ•ˆæœ
     */
    UFUNCTION(BlueprintCallable)
    void RegisterAffixVFX(const FDynamicVFXConfig& Config);
    
    /**
     * åº”ç”¨è¯ç¼€è§†è§‰æ•ˆæœ
     */
    UFUNCTION(BlueprintCallable)
    void ApplyAffixVFX(AActor* Actor, const FGameplayTag& AffixTag, float Intensity = 1.0f);
    
    /**
     * ç§»é™¤è¯ç¼€è§†è§‰æ•ˆæœ
     */
    UFUNCTION(BlueprintCallable)
    void RemoveAffixVFX(AActor* Actor, const FGameplayTag& AffixTag);
    
    /**
     * æ›´æ–°ååŒè§†è§‰æ•ˆæœ
     */
    UFUNCTION(BlueprintCallable)
    void UpdateSynergyVFX(AActor* Actor, const TArray<FGameplayTag>& ActiveAffixes);
    
    /**
     * åˆ›å»ºæš´å‡»ç‰¹æ•ˆ
     */
    UFUNCTION(BlueprintCallable)
    void CreateCriticalHitVFX(AActor* Actor, const FVector& ImpactLocation, float Damage);
    
private:
    // VFXé…ç½®æ˜ å°„
    UPROPERTY()
    TMap<FGameplayTag, FDynamicVFXConfig> VFXConfigs;
    
    // æ´»è·ƒçš„VFXå®ä¾‹
    UPROPERTY()
    TMap<AActor*, TMap<FGameplayTag, UNiagaraComponent*>> ActiveVFXInstances;
    
    /**
     * è®¡ç®—ååŒæ•ˆæœå¼ºåº¦
     */
    float CalculateSynergyIntensity(const FGameplayTag& AffixTag, const TArray<FGameplayTag>& ActiveAffixes);
    
    /**
     * è®¡ç®—ååŒæ•ˆæœé¢œè‰²
     */
    FLinearColor CalculateSynergyColor(const FGameplayTag& AffixTag, const TArray<FGameplayTag>& ActiveAffixes);
    
    /**
     * æ¸…ç†è¿‡æœŸçš„VFX
     */
    void CleanupExpiredVFX();
};
```

---

## æ™ºèƒ½å¹³è¡¡ä¸å¤æ‚åº¦ç®¡ç†

### 1. è‡ªé€‚åº”å¹³è¡¡ç³»ç»Ÿ

```mermaid
graph TB
    subgraph "Data Collection æ•°æ®æ”¶é›†"
        PlayerMetrics[ç©å®¶æŒ‡æ ‡]
        CombatData[æˆ˜æ–—æ•°æ®]
        ProgressData[è¿›åº¦æ•°æ®]
        FeedbackData[åé¦ˆæ•°æ®]
    end
    
    subgraph "Analysis Engine åˆ†æå¼•æ“"
        PowerAnalyzer[åŠ›é‡åˆ†æå™¨]
        DifficultyAssess[éš¾åº¦è¯„ä¼°]
        TrendDetector[è¶‹åŠ¿æ£€æµ‹]
        OutlierDetector[å¼‚å¸¸æ£€æµ‹]
    end
    
    subgraph "Balance Decisions å¹³è¡¡å†³ç­–"
        AutoTuning[è‡ªåŠ¨è°ƒä¼˜]
        ManualReview[æ‰‹åŠ¨å®¡æŸ¥]
        ABTesting[A/Bæµ‹è¯•]
        GradualRollout[æ¸è¿›å‘å¸ƒ]
    end
    
    subgraph "Application Layer åº”ç”¨å±‚"
        DynamicScaling[åŠ¨æ€ç¼©æ”¾]
        ContentGating[å†…å®¹é—¨æ§]
        RewardAdjustment[å¥–åŠ±è°ƒæ•´]
        VariantSelection[å˜ä½“é€‰æ‹©]
    end
    
    %% æ•°æ®æµ
    PlayerMetrics --> PowerAnalyzer
    CombatData --> DifficultyAssess
    ProgressData --> TrendDetector
    FeedbackData --> OutlierDetector
    
    PowerAnalyzer --> AutoTuning
    DifficultyAssess --> ManualReview
    TrendDetector --> ABTesting
    OutlierDetector --> GradualRollout
    
    AutoTuning --> DynamicScaling
    ManualReview --> ContentGating
    ABTesting --> RewardAdjustment
    GradualRollout --> VariantSelection
    
    %% åé¦ˆå¾ªç¯
    DynamicScaling --> PlayerMetrics
    ContentGating --> CombatData
    RewardAdjustment --> ProgressData
    VariantSelection --> FeedbackData
```

### 2. å¤æ‚åº¦æ¸è¿›ç®¡ç†å™¨

```cpp
/**
 * æ™ºèƒ½å¤æ‚åº¦ç®¡ç†å™¨
 * Intelligent complexity manager
 */
UCLASS()
class SAGASTATS_API USagaComplexityManager : public UGameInstanceSubsystem
{
    GENERATED_BODY()

public:
    // å¤æ‚åº¦ç­‰çº§
    UENUM(BlueprintType)
    enum class EComplexityTier : uint8
    {
        Beginner    = 0,    // æ–°æ‰‹ (0-5å°æ—¶)
        Intermediate = 1,   // è¿›é˜¶ (5-20å°æ—¶)
        Advanced    = 2,    // é«˜çº§ (20-50å°æ—¶)
        Expert      = 3,    // ä¸“å®¶ (50-100å°æ—¶)
        Master      = 4     // å¤§å¸ˆ (100+å°æ—¶)
    };
    
    // å¤æ‚åº¦é…ç½®
    USTRUCT()
    struct FComplexityConfig {
        EComplexityTier Tier;
        float RequiredPlayTime;         // éœ€è¦çš„æ¸¸æˆæ—¶é—´
        int32 MaxSimultaneousAffixes;   // æœ€å¤§åŒæ—¶è¯ç¼€æ•°
        int32 MaxAffixTypes;            // æœ€å¤§è¯ç¼€ç±»å‹æ•°
        bool bEnableSynergies;          // å¯ç”¨ååŒæ•ˆåº”
        bool bEnableConflicts;          // å¯ç”¨å†²çªæœºåˆ¶
        bool bEnableAdvancedUI;         // å¯ç”¨é«˜çº§UI
        float RecommendationIntensity;  // æ¨èç³»ç»Ÿå¼ºåº¦
        
        TArray<FGameplayTag> UnlockedCategories;   // è§£é”çš„è¯ç¼€åˆ†ç±»
        TArray<FGameplayTag> UnlockedMechanics;    // è§£é”çš„æœºåˆ¶
    };
    
    /**
     * è·å–ç©å®¶å½“å‰å¤æ‚åº¦ç­‰çº§
     */
    UFUNCTION(BlueprintCallable)
    EComplexityTier GetPlayerComplexityTier(APlayerController* Player);
    
    /**
     * æ£€æŸ¥è¯ç¼€æ˜¯å¦é€‚åˆå½“å‰å¤æ‚åº¦
     */
    UFUNCTION(BlueprintCallable)
    bool IsAffixAppropriate(const FGameplayTag& AffixTag, APlayerController* Player);
    
    /**
     * è·å–æ¨èçš„è¯ç¼€åˆ—è¡¨
     */
    UFUNCTION(BlueprintCallable)
    TArray<FGameplayTag> GetRecommendedAffixes(APlayerController* Player, int32 Count = 3);
    
    /**
     * åº”ç”¨å¤æ‚åº¦é™åˆ¶
     */
    UFUNCTION(BlueprintCallable)
    void ApplyComplexityConstraints(APlayerController* Player, USagaAffixManagerAbility* AffixManager);
    
    /**
     * æ£€æŸ¥æ˜¯å¦å¯ä»¥å‡çº§å¤æ‚åº¦ç­‰çº§
     */
    UFUNCTION(BlueprintCallable)
    bool CanUpgradeComplexityTier(APlayerController* Player);
    
private:
    // å¤æ‚åº¦é…ç½®è¡¨
    UPROPERTY(EditDefaultsOnly)
    TArray<FComplexityConfig> ComplexityConfigs;
    
    // ç©å®¶å¤æ‚åº¦æ•°æ®
    UPROPERTY()
    TMap<APlayerController*, EComplexityTier> PlayerComplexityTiers;
    
    // ç©å®¶æŒæ¡åº¦è¯„ä¼°
    UPROPERTY()
    TMap<APlayerController*, float> PlayerMasteryScores;
    
    /**
     * è¯„ä¼°ç©å®¶æŒæ¡åº¦
     */
    float EvaluatePlayerMastery(APlayerController* Player);
    
    /**
     * åˆ†æè¯ç¼€ä½¿ç”¨æ¨¡å¼
     */
    void AnalyzeAffixUsagePatterns(APlayerController* Player);
    
    /**
     * è®¡ç®—æ¨èå¾—åˆ†
     */
    float CalculateRecommendationScore(const FGameplayTag& AffixTag, APlayerController* Player);
};
```

### 3. AIé©±åŠ¨çš„æ¨èç³»ç»Ÿ

```cpp
/**
 * AIè¯ç¼€æ¨èç³»ç»Ÿ
 * AI-driven affix recommendation system
 */
UCLASS()
class SAGASTATS_API USagaAIRecommendationEngine : public UObject
{
    GENERATED_BODY()

public:
    // æ¨èç±»å‹
    UENUM(BlueprintType)
    enum class ERecommendationType : uint8
    {
        Synergy         UMETA(DisplayName = "ååŒæ¨è"),    // åŸºäºååŒæ•ˆåº”
        Playstyle       UMETA(DisplayName = "é£æ ¼æ¨è"),    // åŸºäºç©æ³•é£æ ¼
        Progression     UMETA(DisplayName = "è¿›åº¦æ¨è"),    // åŸºäºæ¸¸æˆè¿›åº¦
        Challenge       UMETA(DisplayName = "æŒ‘æˆ˜æ¨è"),    // åŸºäºæŒ‘æˆ˜éœ€æ±‚
        Social          UMETA(DisplayName = "ç¤¾äº¤æ¨è"),    // åŸºäºç¤¾åŒºæ•°æ®
        Experimental    UMETA(DisplayName = "å®éªŒæ¨è")     // å°è¯•æ–°ç»„åˆ
    };
    
    // æ¨èç»“æœ
    USTRUCT(BlueprintType)
    struct FAIRecommendation {
        FGameplayTag AffixTag;
        ERecommendationType Type;
        float ConfidenceScore;      // ç½®ä¿¡åº¦åˆ†æ•° (0-1)
        float SynergyScore;         // ååŒæ•ˆåº”åˆ†æ•°
        float NoveltyScore;         // æ–°é¢–æ€§åˆ†æ•°
        FText ReasonDescription;    // æ¨èç†ç”±
        TArray<FGameplayTag> RequiredAffixes;  // å‰ç½®è¯ç¼€
        float EstimatedPowerGain;   // é¢„æœŸåŠ›é‡æå‡
    };
    
    /**
     * ç”Ÿæˆä¸ªæ€§åŒ–æ¨è
     */
    UFUNCTION(BlueprintCallable)
    TArray<FAIRecommendation> GeneratePersonalizedRecommendations(
        APlayerController* Player, 
        int32 RecommendationCount = 5,
        TArray<ERecommendationType> PreferredTypes = {}
    );
    
    /**
     * åˆ†æç©å®¶åå¥½
     */
    UFUNCTION(BlueprintCallable)
    void AnalyzePlayerPreferences(APlayerController* Player);
    
    /**
     * å­¦ä¹ ç¤¾åŒºè¶‹åŠ¿
     */
    UFUNCTION(BlueprintCallable)
    void LearnFromCommunityData(const TArray<FPlayerAffixData>& CommunityData);
    
    /**
     * é¢„æµ‹è¯ç¼€ç»„åˆæ•ˆæœ
     */
    UFUNCTION(BlueprintCallable)
    float PredictCombinationEffectiveness(const TArray<FGameplayTag>& AffixCombination, APlayerController* Player);
    
private:
    // ç©å®¶è¡Œä¸ºæ•°æ®ç»“æ„
    USTRUCT()
    struct FPlayerBehaviorData {
        TMap<FGameplayTag, float> AffixUsageFrequency;
        TMap<FGameplayTag, float> AffixSuccessRate;
        TArray<FGameplayTag> PreferredCombinations;
        float AverageSessionLength;
        float ChallengePreference;
        float ExperimentationTendency;
    };
    
    // ç©å®¶è¡Œä¸ºåˆ†æ
    UPROPERTY()
    TMap<APlayerController*, FPlayerBehaviorData> PlayerBehaviorProfiles;
    
    // ç¤¾åŒºå…ƒæ•°æ®
    UPROPERTY()
    TMap<FGameplayTag, float> CommunityPopularity;
    
    UPROPERTY()
    TMap<TArray<FGameplayTag>, float> CommunityComboEffectiveness;
    
    /**
     * æœºå™¨å­¦ä¹ æ¨¡å‹æ¥å£
     */
    class IMLModel {
    public:
        virtual float Predict(const TArray<float>& Features) = 0;
        virtual void Train(const TArray<TArray<float>>& TrainingData, const TArray<float>& Labels) = 0;
        virtual void UpdateModel(const TArray<float>& NewData, float NewLabel) = 0;
    };
    
    // ä¸åŒç±»å‹çš„MLæ¨¡å‹
    TUniquePtr<IMLModel> SynergyPredictionModel;
    TUniquePtr<IMLModel> PlaystylePredictionModel;
    TUniquePtr<IMLModel> EffectivenessPredictionModel;
    
    /**
     * ç‰¹å¾æå–
     */
    TArray<float> ExtractPlayerFeatures(APlayerController* Player);
    TArray<float> ExtractAffixFeatures(const FGameplayTag& AffixTag);
    TArray<float> ExtractCombinationFeatures(const TArray<FGameplayTag>& AffixCombination);
    
    /**
     * æ¨èç®—æ³•
     */
    TArray<FAIRecommendation> GenerateSynergyRecommendations(APlayerController* Player, int32 Count);
    TArray<FAIRecommendation> GeneratePlaystyleRecommendations(APlayerController* Player, int32 Count);
    TArray<FAIRecommendation> GenerateNoveltyRecommendations(APlayerController* Player, int32 Count);
};
```

---

## ç¤¾åŒºä¸åˆ›ä½œæ”¯æŒ

### 1. æ„å»ºåˆ†äº«ç³»ç»Ÿ

```mermaid
graph TB
    subgraph "Creation Tools åˆ›ä½œå·¥å…·"
        BuildEditor[æ„å»ºç¼–è¾‘å™¨]
        VisualPreview[å¯è§†åŒ–é¢„è§ˆ]
        EffectSimulator[æ•ˆæœæ¨¡æ‹Ÿå™¨]
        PerformanceAnalyzer[æ€§èƒ½åˆ†æå™¨]
    end
    
    subgraph "Sharing Platform åˆ†äº«å¹³å°"
        BuildUploader[æ„å»ºä¸Šä¼ å™¨]
        TagSystem[æ ‡ç­¾ç³»ç»Ÿ]
        SearchEngine[æœç´¢å¼•æ“]
        RatingSystem[è¯„åˆ†ç³»ç»Ÿ]
    end
    
    subgraph "Community Features ç¤¾åŒºåŠŸèƒ½"
        Comments[è¯„è®ºç³»ç»Ÿ]
        Variations[å˜ä½“åˆ›ä½œ]
        Challenges[æŒ‘æˆ˜ç³»ç»Ÿ]
        Competitions[ç«èµ›ç³»ç»Ÿ]
    end
    
    subgraph "Discovery Engine å‘ç°å¼•æ“"
        TrendingAlgorithm[çƒ­é—¨ç®—æ³•]
        PersonalizedFeed[ä¸ªæ€§åŒ–æ¨é€]
        CategoryBrowsing[åˆ†ç±»æµè§ˆ]
        InfluencerHighlights[è¾¾äººæ¨è]
    end
    
    %% åˆ›ä½œæµç¨‹
    BuildEditor --> VisualPreview
    VisualPreview --> EffectSimulator
    EffectSimulator --> PerformanceAnalyzer
    
    %% åˆ†äº«æµç¨‹
    PerformanceAnalyzer --> BuildUploader
    BuildUploader --> TagSystem
    TagSystem --> SearchEngine
    SearchEngine --> RatingSystem
    
    %% ç¤¾åŒºäº’åŠ¨
    RatingSystem --> Comments
    Comments --> Variations
    Variations --> Challenges
    Challenges --> Competitions
    
    %% å‘ç°æœºåˆ¶
    Competitions --> TrendingAlgorithm
    TrendingAlgorithm --> PersonalizedFeed
    PersonalizedFeed --> CategoryBrowsing
    CategoryBrowsing --> InfluencerHighlights
    
    %% åé¦ˆå¾ªç¯
    InfluencerHighlights --> BuildEditor
    PersonalizedFeed --> VisualPreview
```

### 2. è¯ç¼€æ„å»ºåˆ†äº«ç³»ç»Ÿ

```cpp
/**
 * è¯ç¼€æ„å»ºåˆ†äº«ç³»ç»Ÿ
 * Affix build sharing system
 */
UCLASS()
class SAGASTATS_API USagaAffixBuildSharingSystem : public UGameInstanceSubsystem
{
    GENERATED_BODY()

public:
    // æ„å»ºæ•°æ®ç»“æ„
    USTRUCT(BlueprintType)
    struct FSagaAffixBuild {
        FString BuildID;                    // æ„å»ºå”¯ä¸€ID
        FString BuildName;                  // æ„å»ºåç§°
        FString CreatorName;                // åˆ›å»ºè€…åç§°
        FText Description;                  // æ„å»ºæè¿°
        
        TArray<FGameplayTag> AffixTags;     // è¯ç¼€æ ‡ç­¾åˆ—è¡¨
        TMap<FGameplayTag, float> AffixLevels;  // è¯ç¼€ç­‰çº§
        
        // å…ƒæ•°æ®
        FDateTime CreationTime;             // åˆ›å»ºæ—¶é—´
        FDateTime LastModified;             // æœ€åä¿®æ”¹æ—¶é—´
        int32 DownloadCount;                // ä¸‹è½½æ¬¡æ•°
        float AverageRating;                // å¹³å‡è¯„åˆ†
        int32 RatingCount;                  // è¯„åˆ†äººæ•°
        
        // åˆ†ç±»æ ‡ç­¾
        TArray<FString> BuildTags;          // æ„å»ºæ ‡ç­¾
        FString Playstyle;                  // æ¸¸æˆé£æ ¼
        FString Difficulty;                 // éš¾åº¦ç­‰çº§
        
        // æ€§èƒ½æ•°æ®
        float EstimatedDPS;                 // é¢„è®¡DPS
        float EstimatedSurvivability;       // é¢„è®¡ç”Ÿå­˜èƒ½åŠ›
        float ComplexityScore;              // å¤æ‚åº¦åˆ†æ•°
        
        // ç¤¾åŒºæ•°æ®
        TArray<FString> Comments;           // è¯„è®ºåˆ—è¡¨
        TArray<FString> Variations;         // å˜ä½“æ„å»ºID
        bool bIsFeatured;                   // æ˜¯å¦ç²¾é€‰
        bool bIsVerified;                   // æ˜¯å¦éªŒè¯
    };
    
    // æœç´¢ç­›é€‰æ¡ä»¶
    USTRUCT(BlueprintType)
    struct FAffixBuildSearchFilter {
        FString SearchText;                 // æœç´¢æ–‡æœ¬
        TArray<FString> RequiredTags;       // å¿…éœ€æ ‡ç­¾
        TArray<FString> ExcludedTags;       // æ’é™¤æ ‡ç­¾
        FString Playstyle;                  // æ¸¸æˆé£æ ¼
        float MinRating = 0.0f;             // æœ€ä½è¯„åˆ†
        int32 MinDownloads = 0;             // æœ€å°‘ä¸‹è½½æ•°
        bool bFeaturedOnly = false;         // ä»…ç²¾é€‰æ„å»º
        bool bVerifiedOnly = false;         // ä»…éªŒè¯æ„å»º
        
        // æ’åºæ–¹å¼
        enum class ESortBy {
            Newest,
            Rating,
            Downloads,
            Relevance
        } SortBy = ESortBy::Relevance;
    };
    
    /**
     * ä¸Šä¼ æ„å»º
     */
    UFUNCTION(BlueprintCallable)
    FString UploadBuild(const FSagaAffixBuild& Build, APlayerController* Uploader);
    
    /**
     * ä¸‹è½½æ„å»º
     */
    UFUNCTION(BlueprintCallable)
    bool DownloadBuild(const FString& BuildID, FSagaAffixBuild& OutBuild);
    
    /**
     * æœç´¢æ„å»º
     */
    UFUNCTION(BlueprintCallable)
    TArray<FSagaAffixBuild> SearchBuilds(const FAffixBuildSearchFilter& Filter, int32 MaxResults = 50);
    
    /**
     * åº”ç”¨æ„å»ºåˆ°ç©å®¶
     */
    UFUNCTION(BlueprintCallable)
    bool ApplyBuildToPlayer(const FSagaAffixBuild& Build, APlayerController* Player);
    
    /**
     * è¯„åˆ†æ„å»º
     */
    UFUNCTION(BlueprintCallable)
    bool RateBuild(const FString& BuildID, float Rating, APlayerController* Rater);
    
    /**
     * åˆ›å»ºæ„å»ºå˜ä½“
     */
    UFUNCTION(BlueprintCallable)
    FString CreateBuildVariation(const FString& OriginalBuildID, const FSagaAffixBuild& VariationBuild, APlayerController* Creator);
    
private:
    // æ„å»ºæ•°æ®åº“æ¥å£
    class IBuildDatabase {
    public:
        virtual bool StoreBuild(const FSagaAffixBuild& Build) = 0;
        virtual bool RetrieveBuild(const FString& BuildID, FSagaAffixBuild& OutBuild) = 0;
        virtual TArray<FSagaAffixBuild> QueryBuilds(const FAffixBuildSearchFilter& Filter) = 0;
        virtual bool UpdateBuildMetadata(const FString& BuildID, const FSagaAffixBuild& UpdatedBuild) = 0;
        virtual bool DeleteBuild(const FString& BuildID) = 0;
    };
    
    TUniquePtr<IBuildDatabase> BuildDatabase;
    
    // æ¨èç®—æ³•
    class IBuildRecommendationAlgorithm {
    public:
        virtual TArray<FString> RecommendBuilds(APlayerController* Player, int32 Count) = 0;
        virtual float CalculateSimilarity(const FSagaAffixBuild& Build1, const FSagaAffixBuild& Build2) = 0;
        virtual void UpdateRecommendationModel(const TArray<FSagaAffixBuild>& NewBuilds) = 0;
    };
    
    TUniquePtr<IBuildRecommendationAlgorithm> RecommendationEngine;
    
    /**
     * éªŒè¯æ„å»ºåˆæ³•æ€§
     */
    bool ValidateBuild(const FSagaAffixBuild& Build, FString& OutErrorMessage);
    
    /**
     * ç”Ÿæˆæ„å»ºID
     */
    FString GenerateBuildID(const FSagaAffixBuild& Build);
    
    /**
     * è®¡ç®—æ„å»ºå¤æ‚åº¦
     */
    float CalculateBuildComplexity(const FSagaAffixBuild& Build);
    
    /**
     * è‡ªåŠ¨æ ‡è®°çƒ­é—¨æ„å»º
     */
    void UpdateTrendingBuilds();
};
```

### 3. ç¤¾åŒºæŒ‘æˆ˜ç³»ç»Ÿ

```cpp
/**
 * ç¤¾åŒºæŒ‘æˆ˜ç³»ç»Ÿ
 * Community challenge system
 */
UCLASS()
class SAGASTATS_API USagaCommunityChallenge : public UGameInstanceSubsystem
{
    GENERATED_BODY()

public:
    // æŒ‘æˆ˜ç±»å‹
    UENUM(BlueprintType)
    enum class EChallengeType : uint8
    {
        BuildChallenge      UMETA(DisplayName = "æ„å»ºæŒ‘æˆ˜"),    // ç‰¹å®šæ„å»ºè¦æ±‚
        SpeedRun           UMETA(DisplayName = "é€Ÿé€šæŒ‘æˆ˜"),     // é€Ÿåº¦é€šå…³
        SurvivalChallenge  UMETA(DisplayName = "ç”Ÿå­˜æŒ‘æˆ˜"),     // ç”Ÿå­˜æ—¶é—´
        CreativityChallenge UMETA(DisplayName = "åˆ›æ„æŒ‘æˆ˜"),    // åˆ›æ„æ„å»º
        CollaborativeChallenge UMETA(DisplayName = "åä½œæŒ‘æˆ˜"), // å›¢é˜Ÿåä½œ
        SeasonalEvent      UMETA(DisplayName = "å­£èŠ‚æ´»åŠ¨")      // å­£èŠ‚æ€§æ´»åŠ¨
    };
    
    // æŒ‘æˆ˜å®šä¹‰
    USTRUCT(BlueprintType)
    struct FCommunityChallenge {
        FString ChallengeID;
        FString ChallengeName;
        FText Description;
        EChallengeType Type;
        
        // æ—¶é—´é™åˆ¶
        FDateTime StartTime;
        FDateTime EndTime;
        
        // æŒ‘æˆ˜æ¡ä»¶
        TArray<FGameplayTag> RequiredAffixes;      // å¿…éœ€è¯ç¼€
        TArray<FGameplayTag> BannedAffixes;        // ç¦ç”¨è¯ç¼€
        int32 MaxAffixes = -1;                     // æœ€å¤§è¯ç¼€æ•°é‡
        float TargetTime = -1.0f;                  // ç›®æ ‡æ—¶é—´
        float TargetScore = -1.0f;                 // ç›®æ ‡åˆ†æ•°
        
        // å¥–åŠ±è®¾ç½®
        TArray<FString> RewardTiers;               // å¥–åŠ±å±‚æ¬¡
        TMap<FString, TArray<FString>> TierRewards; // å±‚æ¬¡å¥–åŠ±
        
        // ç¤¾åŒºç›®æ ‡
        int32 ParticipationGoal = 1000;           // å‚ä¸ç›®æ ‡
        float CommunityTarget = 0.0f;             // ç¤¾åŒºç›®æ ‡
        bool bIsGlobalChallenge = false;          // å…¨çƒæŒ‘æˆ˜
        
        // å½“å‰çŠ¶æ€
        int32 CurrentParticipants = 0;            // å½“å‰å‚ä¸è€…
        float CurrentProgress = 0.0f;             // å½“å‰è¿›åº¦
        TArray<FString> Leaderboard;              // æ’è¡Œæ¦œ
    };
    
    /**
     * åˆ›å»ºæŒ‘æˆ˜
     */
    UFUNCTION(BlueprintCallable)
    FString CreateChallenge(const FCommunityChallenge& Challenge, APlayerController* Creator);
    
    /**
     * å‚ä¸æŒ‘æˆ˜
     */
    UFUNCTION(BlueprintCallable)
    bool JoinChallenge(const FString& ChallengeID, APlayerController* Player);
    
    /**
     * æäº¤æŒ‘æˆ˜ç»“æœ
     */
    UFUNCTION(BlueprintCallable)
    bool SubmitChallengeResult(const FString& ChallengeID, APlayerController* Player, 
                              float Score, const TArray<FString>& EvidenceData);
    
    /**
     * è·å–æ´»è·ƒæŒ‘æˆ˜åˆ—è¡¨
     */
    UFUNCTION(BlueprintCallable)
    TArray<FCommunityChallenge> GetActiveChallenges(EChallengeType Type = EChallengeType::BuildChallenge);
    
    /**
     * è·å–æŒ‘æˆ˜æ’è¡Œæ¦œ
     */
    UFUNCTION(BlueprintCallable)
    TArray<FString> GetChallengeLeaderboard(const FString& ChallengeID, int32 MaxEntries = 100);
    
    /**
     * ç”Ÿæˆä¸ªæ€§åŒ–æŒ‘æˆ˜
     */
    UFUNCTION(BlueprintCallable)
    FCommunityChallenge GeneratePersonalizedChallenge(APlayerController* Player);
    
private:
    // æŒ‘æˆ˜æ•°æ®åº“
    UPROPERTY()
    TMap<FString, FCommunityChallenge> ActiveChallenges;
    
    // ç©å®¶å‚ä¸è®°å½•
    UPROPERTY()
    TMap<APlayerController*, TArray<FString>> PlayerChallengeHistory;
    
    // æŒ‘æˆ˜ç»“æœè®°å½•
    USTRUCT()
    struct FChallengeResult {
        FString ChallengeID;
        APlayerController* Player;
        float Score;
        FDateTime SubmissionTime;
        TArray<FString> EvidenceData;
        bool bVerified = false;
    };
    
    UPROPERTY()
    TArray<FChallengeResult> ChallengeResults;
    
    /**
     * éªŒè¯æŒ‘æˆ˜ç»“æœ
     */
    bool VerifyChallengeResult(const FChallengeResult& Result);
    
    /**
     * æ›´æ–°æ’è¡Œæ¦œ
     */
    void UpdateLeaderboard(const FString& ChallengeID);
    
    /**
     * åˆ†å‘å¥–åŠ±
     */
    void DistributeRewards(const FString& ChallengeID);
    
    /**
     * ç”ŸæˆæŒ‘æˆ˜ID
     */
    FString GenerateChallengeID();
};
```

---

## æ ¸å¿ƒç±»è®¾è®¡ä¼˜åŒ–

### 1. USagaAffixManagerAbility åŠ¨ä½œæ¸¸æˆä¼˜åŒ–ç‰ˆ

```cpp
/**
 * åŠ¨ä½œæ¸¸æˆä¼˜åŒ–çš„è¯ç¼€ç®¡ç†å™¨
 * Action game optimized affix manager
 */
UCLASS(BlueprintType, Blueprintable)
class SAGASTATS_API USagaActionAffixManagerAbility : public UGameplayAbility
{
    GENERATED_BODY()

public:
    USagaActionAffixManagerAbility();

    // === åŠ¨ä½œæ¸¸æˆç‰¹åŒ–æ¥å£ ===
    
    /**
     * å¿«é€Ÿåº”ç”¨è¯ç¼€ï¼ˆåŠ¨ä½œæ¸¸æˆä¼˜åŒ–ï¼‰
     * Fast affix application (action game optimized)
     */
    UFUNCTION(BlueprintCallable, Category = "SagaAffix|ActionGame")
    bool FastApplyAffix(AActor* Target, FGameplayTag AffixTag, float Level = 1.0f, 
                       bool bUsePrediction = true, bool bInstantFeedback = true);
    
    /**
     * é¢„æµ‹è¯ç¼€æ•ˆæœï¼ˆé›¶å»¶è¿Ÿåé¦ˆï¼‰
     * Predict affix effects (zero latency feedback)
     */
    UFUNCTION(BlueprintCallable, Category = "SagaAffix|ActionGame")
    void PredictAffixEffect(AActor* Target, FGameplayTag AffixTag, float Level,
                           FGameplayEventData& OutPredictedEffect);
    
    /**
     * æ‰¹é‡å¤„ç†è¯ç¼€å˜åŒ–ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
     * Batch process affix changes (performance optimization)
     */
    UFUNCTION(BlueprintCallable, Category = "SagaAffix|ActionGame")
    void BatchProcessAffixChanges(const TArray<FSagaAffixBatchOperation>& Operations);
    
    /**
     * è§¦å‘æš´çˆ½æ—¶åˆ»æ•ˆæœ
     * Trigger epic moment effects
     */
    UFUNCTION(BlueprintCallable, Category = "SagaAffix|ActionGame")
    bool TriggerEpicMoment(AActor* Actor, const TArray<FGameplayTag>& ComboAffixes, float Intensity);
    
    /**
     * å®æ—¶æ›´æ–°è¯ç¼€å¼ºåº¦ï¼ˆåŠ¨æ€å¹³è¡¡ï¼‰
     * Real-time update affix intensity (dynamic balancing)
     */
    UFUNCTION(BlueprintCallable, Category = "SagaAffix|ActionGame")
    void UpdateAffixIntensity(const FGameplayTag& AffixTag, float NewIntensity, bool bGradualTransition = true);

    // === åŠ¨ä½œæ¸¸æˆå“åº”ä¼˜åŒ– ===
    
    /**
     * è·å–é«˜ä¼˜å…ˆçº§è¯ç¼€
     * Get high priority affixes
     */
    UFUNCTION(BlueprintCallable, Category = "SagaAffix|ActionGame")
    TArray<FGameplayTag> GetHighPriorityAffixes(AActor* Actor) const;
    
    /**
     * å¤„ç†è¿å‡»è¯ç¼€æ¿€æ´»
     * Handle combo affix activation
     */
    UFUNCTION(BlueprintCallable, Category = "SagaAffix|ActionGame")
    void ProcessComboActivation(AActor* Actor, const TArray<FGameplayTag>& ComboSequence);
    
    /**
     * æ£€æŸ¥å¹¶è§¦å‘ååŒçˆ†å‘
     * Check and trigger synergy burst
     */
    UFUNCTION(BlueprintCallable, Category = "SagaAffix|ActionGame")
    bool CheckAndTriggerSynergyBurst(AActor* Actor);

protected:
    // === åŠ¨ä½œæ¸¸æˆç‰¹åŒ–é…ç½® ===
    
    /** å¿«é€Ÿå“åº”é˜ˆå€¼ï¼ˆæ¯«ç§’ï¼‰*/
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "ActionGame|Performance")
    float FastResponseThreshold = 16.0f;
    
    /** é¢„æµ‹ç²¾åº¦ç­‰çº§ */
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "ActionGame|Performance")
    int32 PredictionAccuracyLevel = 3;
    
    /** æ‰¹å¤„ç†å¤§å° */
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "ActionGame|Performance")
    int32 BatchProcessingSize = 10;
    
    /** æš´çˆ½æ—¶åˆ»å†·å´æ—¶é—´ */
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "ActionGame|Experience")
    float EpicMomentCooldown = 5.0f;
    
    /** è¿å‡»æ£€æµ‹çª—å£æ—¶é—´ */
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "ActionGame|Experience")
    float ComboDetectionWindow = 2.0f;

    // === æ€§èƒ½ä¼˜åŒ–ç»„ä»¶ ===
    
    /** é¢„è®¡ç®—ç¼“å­˜ç®¡ç†å™¨ */
    UPROPERTY(BlueprintReadOnly, Category = "ActionGame|Performance")
    USagaAffixPreComputeCache* PreComputeCache;
    
    /** åŠ¨æ€VFXç®¡ç†å™¨ */
    UPROPERTY(BlueprintReadOnly, Category = "ActionGame|Experience")
    USagaDynamicVFXManager* VFXManager;
    
    /** æš´çˆ½æ—¶åˆ»ç®¡ç†å™¨ */
    UPROPERTY(BlueprintReadOnly, Category = "ActionGame|Experience")
    USagaEpicMomentManager* EpicMomentManager;
    
    /** å¤æ‚åº¦ç®¡ç†å™¨ */
    UPROPERTY(BlueprintReadOnly, Category = "ActionGame|Balance")
    USagaComplexityManager* ComplexityManager;

    // === åŠ¨ä½œæ¸¸æˆç‰¹åŒ–æ–¹æ³• ===
    
    /**
     * å¿«é€Ÿæ•ˆæœé¢„æµ‹
     */
    virtual void FastEffectPrediction(const FGameplayTag& AffixTag, AActor* Target, 
                                    FSagaAffixEffectPrediction& OutPrediction);
    
    /**
     * ä¼˜åŒ–çš„å†²çªæ£€æµ‹
     */
    virtual bool OptimizedConflictDetection(const FGameplayTag& AffixTag, AActor* Target);
    
    /**
     * æ™ºèƒ½ååŒæ£€æµ‹
     */
    virtual TArray<FGameplayTag> IntelligentSynergyDetection(const TArray<FGameplayTag>& CurrentAffixes, 
                                                           const FGameplayTag& NewAffixTag);
    
    /**
     * åŠ¨æ€éš¾åº¦è°ƒæ•´
     */
    virtual void DynamicDifficultyAdjustment(AActor* Actor, float PerformanceScore);

    // === äº‹ä»¶å“åº”ä¼˜åŒ– ===
    
    /** é«˜ä¼˜å…ˆçº§äº‹ä»¶é˜Ÿåˆ— */
    TQueue<FGameplayEventData> HighPriorityEventQueue;
    
    /** æ‰¹å¤„ç†äº‹ä»¶é˜Ÿåˆ— */
    TQueue<FGameplayEventData> BatchEventQueue;
    
    /** å¤„ç†é«˜ä¼˜å…ˆçº§äº‹ä»¶ */
    virtual void ProcessHighPriorityEvents();
    
    /** å¤„ç†æ‰¹é‡äº‹ä»¶ */
    virtual void ProcessBatchEvents();

private:
    // === æ€§èƒ½ç›‘æ§ ===
    
    /** å“åº”æ—¶é—´ç»Ÿè®¡ */
    UPROPERTY()
    TMap<FGameplayTag, float> AffixResponseTimes;
    
    /** æ€§èƒ½æŒ‡æ ‡æ”¶é›† */
    void CollectPerformanceMetrics(const FGameplayTag& AffixTag, float ResponseTime);
    
    /** è‡ªåŠ¨æ€§èƒ½ä¼˜åŒ– */
    void AutoPerformanceOptimization();
};
```

### 2. åŠ¨ä½œæ¸¸æˆæ•°æ®ç»“æ„ä¼˜åŒ–

```cpp
/**
 * åŠ¨ä½œæ¸¸æˆæ‰¹å¤„ç†æ“ä½œ
 * Action game batch operation
 */
USTRUCT(BlueprintType)
struct SAGASTATS_API FSagaAffixBatchOperation
{
    GENERATED_BODY()

    /** æ“ä½œç±»å‹ */
    UENUM(BlueprintType)
    enum class EOperationType : uint8
    {
        Apply       UMETA(DisplayName = "åº”ç”¨"),
        Remove      UMETA(DisplayName = "ç§»é™¤"),
        Update      UMETA(DisplayName = "æ›´æ–°"),
        Suspend     UMETA(DisplayName = "æš‚åœ"),
        Resume      UMETA(DisplayName = "æ¢å¤")
    };

    /** æ“ä½œç±»å‹ */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    EOperationType OperationType = EOperationType::Apply;

    /** ç›®æ ‡Actor */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    AActor* TargetActor = nullptr;

    /** è¯ç¼€æ ‡ç­¾ */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FGameplayTag AffixTag;

    /** æ“ä½œå‚æ•° */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float OperationValue = 1.0f;

    /** æ“ä½œä¼˜å…ˆçº§ */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    int32 Priority = 0;

    /** æ˜¯å¦éœ€è¦å³æ—¶åé¦ˆ */
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    bool bRequiresInstantFeedback = true;

    FSagaAffixBatchOperation()
    {
        OperationType = EOperationType::Apply;
        TargetActor = nullptr;
        AffixTag = FGameplayTag::EmptyTag;
        OperationValue = 1.0f;
        Priority = 0;
        bRequiresInstantFeedback = true;
    }
};

/**
 * åŠ¨ä½œæ¸¸æˆæ•ˆæœé¢„æµ‹
 * Action game effect prediction
 */
USTRUCT(BlueprintType)
struct SAGASTATS_API FSagaAffixEffectPrediction
{
    GENERATED_BODY()

    /** é¢„æµ‹çš„æ•°å€¼å˜åŒ– */
    UPROPERTY(BlueprintReadOnly)
    TMap<FGameplayAttribute, float> PredictedAttributeChanges;

    /** é¢„æµ‹çš„è§†è§‰æ•ˆæœ */
    UPROPERTY(BlueprintReadOnly)
    TArray<FString> PredictedVFX;

    /** é¢„æµ‹çš„éŸ³æ•ˆ */
    UPROPERTY(BlueprintReadOnly)
    TArray<FString> PredictedAudio;

    /** é¢„æµ‹ç½®ä¿¡åº¦ (0-1) */
    UPROPERTY(BlueprintReadOnly)
    float ConfidenceLevel = 0.8f;

    /** é¢„æµ‹å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰*/
    UPROPERTY(BlueprintReadOnly)
    float PredictionLatency = 0.0f;

    /** æ˜¯å¦éœ€è¦æœåŠ¡å™¨éªŒè¯ */
    UPROPERTY(BlueprintReadOnly)
    bool bNeedsServerValidation = true;

    FSagaAffixEffectPrediction()
    {
        ConfidenceLevel = 0.8f;
        PredictionLatency = 0.0f;
        bNeedsServerValidation = true;
    }
};
```

---

## åŠ¨ä½œæ¸¸æˆæµç¨‹ä¼˜åŒ–

### 1. ä¼˜åŒ–çš„è¯ç¼€åº”ç”¨æµç¨‹

```mermaid
sequenceDiagram
    participant Player as ç©å®¶è¾“å…¥
    participant FastTrack as å¿«é€Ÿé€šé“
    participant Predictor as æ•ˆæœé¢„æµ‹å™¨
    participant VFX as è§†è§‰åé¦ˆ
    participant ASC as GASéªŒè¯
    participant Sync as ç½‘ç»œåŒæ­¥
    
    Note over Player,Sync: åŠ¨ä½œæ¸¸æˆ16mså“åº”ç›®æ ‡
    
    Player->>FastTrack: è¯ç¼€è§¦å‘ (0ms)
    FastTrack->>Predictor: å¿«é€Ÿé¢„æµ‹ (1ms)
    Predictor-->>FastTrack: é¢„æµ‹ç»“æœ (3ms)
    
    par å¹¶è¡Œåé¦ˆ
        FastTrack->>VFX: å³æ—¶è§†è§‰åé¦ˆ (4ms)
        FastTrack->>Player: è§¦è§‰åé¦ˆ (4ms)
    end
    
    Note over FastTrack: 16mså“åº”å®Œæˆ
    
    par åå°éªŒè¯
        FastTrack->>ASC: ç²¾ç¡®è®¡ç®— (5ms)
        ASC->>ASC: æœåŠ¡å™¨éªŒè¯ (20ms)
        ASC-->>Sync: åŒæ­¥ç»“æœ (25ms)
    end
    
    alt é¢„æµ‹æ­£ç¡®
        Sync->>VFX: ç¡®è®¤æ•ˆæœ (26ms)
    else é¢„æµ‹é”™è¯¯  
        Sync->>VFX: å¹³æ»‘ä¿®æ­£ (26ms)
        VFX->>VFX: è¿‡æ¸¡åŠ¨ç”» (50ms)
    end
```

### 2. è¿å‡»ç³»ç»Ÿé›†æˆæµç¨‹

```mermaid
stateDiagram-v2
    [*] --> Idle : ç©ºé—²çŠ¶æ€
    
    Idle --> FirstHit : é¦–æ¬¡æ”»å‡»
    FirstHit --> ComboWindow : è¿›å…¥è¿å‡»çª—å£
    
    ComboWindow --> SecondHit : è¿å‡»æˆåŠŸ
    ComboWindow --> Idle : è¿å‡»è¶…æ—¶
    
    SecondHit --> ComboBuilding : è¿å‡»å»ºç«‹
    ComboBuilding --> HigherCombo : ç»§ç»­è¿å‡»
    ComboBuilding --> ComboFinish : è¿å‡»ç»“æŸ
    ComboBuilding --> Idle : è¿å‡»ä¸­æ–­
    
    HigherCombo --> UltimateCombo : è¾¾åˆ°ç»ˆæè¿å‡»
    HigherCombo --> ComboFinish : è¿å‡»ç»“æŸ
    HigherCombo --> Idle : è¿å‡»ä¸­æ–­
    
    UltimateCombo --> EpicMoment : è§¦å‘æš´çˆ½æ—¶åˆ»
    ComboFinish --> Idle : è¿”å›ç©ºé—²
    EpicMoment --> Idle : æ•ˆæœç»“æŸ
    
    note right of ComboWindow
        æ£€æµ‹è¯ç¼€ååŒ
        é¢„æµ‹è¿å‡»æ•ˆæœ
        å‡†å¤‡è§†è§‰åé¦ˆ
    end note
    
    note right of ComboBuilding
        åº”ç”¨è¿å‡»åŠ æˆ
        è§¦å‘ååŒæ•ˆåº”
        å¢å¼ºè§†è§‰è¡¨ç°
    end note
    
    note right of EpicMoment
        æœ€å¤§åŒ–è§†è§‰å†²å‡»
        å…¨å±ç‰¹æ•ˆå±•ç¤º
        éŸ³æ•ˆå’Œéœ‡åŠ¨åŒæ­¥
    end note
```

---

## ç½‘ç»œæ¶æ„å¢å¼º

### 1. åŠ¨ä½œæ¸¸æˆç½‘ç»œä¼˜åŒ–

```mermaid
graph TB
    subgraph "Client Prediction Layer å®¢æˆ·ç«¯é¢„æµ‹å±‚"
        InputPredictor[è¾“å…¥é¢„æµ‹å™¨]
        EffectPredictor[æ•ˆæœé¢„æµ‹å™¨]
        StatePredictor[çŠ¶æ€é¢„æµ‹å™¨]
        FeedbackGenerator[åé¦ˆç”Ÿæˆå™¨]
    end
    
    subgraph "Server Authority Layer æœåŠ¡å™¨æƒå¨å±‚"
        AuthorityValidator[æƒå¨éªŒè¯å™¨]
        ConflictResolver[å†²çªè§£å†³å™¨]
        StateAuthority[çŠ¶æ€æƒå¨]
        AntiCheat[åä½œå¼Šç³»ç»Ÿ]
    end
    
    subgraph "Network Optimization Layer ç½‘ç»œä¼˜åŒ–å±‚"
        DeltaCompression[å¢é‡å‹ç¼©]
        BatchProcessor[æ‰¹å¤„ç†å™¨]
        PriorityQueue[ä¼˜å…ˆçº§é˜Ÿåˆ—]
        AdaptiveBandwidth[è‡ªé€‚åº”å¸¦å®½]
    end
    
    subgraph "Synchronization Layer åŒæ­¥å±‚"
        ClientSync[å®¢æˆ·ç«¯åŒæ­¥]
        ServerSync[æœåŠ¡å™¨åŒæ­¥]
        ConflictResolution[å†²çªè§£å†³]
        RollbackSystem[å›æ»šç³»ç»Ÿ]
    end
    
    %% é¢„æµ‹æµç¨‹
    InputPredictor --> EffectPredictor
    EffectPredictor --> StatePredictor
    StatePredictor --> FeedbackGenerator
    
    %% éªŒè¯æµç¨‹
    StatePredictor --> AuthorityValidator
    AuthorityValidator --> ConflictResolver
    ConflictResolver --> StateAuthority
    StateAuthority --> AntiCheat
    
    %% ç½‘ç»œä¼˜åŒ–
    FeedbackGenerator --> DeltaCompression
    AntiCheat --> BatchProcessor
    DeltaCompression --> PriorityQueue
    BatchProcessor --> AdaptiveBandwidth
    
    %% åŒæ­¥å¤„ç†
    PriorityQueue --> ClientSync
    AdaptiveBandwidth --> ServerSync
    ClientSync --> ConflictResolution
    ServerSync --> RollbackSystem
    
    %% å›é¦ˆå¾ªç¯
    RollbackSystem --> StatePredictor
    ConflictResolution --> EffectPredictor
```

### 2. æ™ºèƒ½ç½‘ç»œåŒæ­¥ç­–ç•¥

```cpp
/**
 * æ™ºèƒ½ç½‘ç»œåŒæ­¥ç®¡ç†å™¨
 * Intelligent network synchronization manager
 */
UCLASS()
class SAGASTATS_API USagaIntelligentNetSync : public UObject
{
    GENERATED_BODY()

public:
    // ç½‘ç»œä¼˜å…ˆçº§ç­‰çº§
    UENUM(BlueprintType)
    enum class ENetworkPriority : uint8
    {
        Critical    = 0,    // å…³é”®æ“ä½œï¼ˆæ”»å‡»ã€é˜²å¾¡ï¼‰
        High        = 1,    // é‡è¦æ“ä½œï¼ˆç§»åŠ¨ã€æŠ€èƒ½ï¼‰
        Medium      = 2,    // ä¸€èˆ¬æ“ä½œï¼ˆè¯ç¼€åº”ç”¨ï¼‰
        Low         = 3,    // æ¬¡è¦æ“ä½œï¼ˆUIæ›´æ–°ï¼‰
        Background  = 4     // åå°æ“ä½œï¼ˆç»Ÿè®¡ã€æ—¥å¿—ï¼‰
    };
    
    // æ™ºèƒ½åŒæ­¥é…ç½®
    USTRUCT()
    struct FIntelligentSyncConfig {
        ENetworkPriority Priority;
        float MaxLatency;           // æœ€å¤§å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
        bool bUsePrediction;        // ä½¿ç”¨é¢„æµ‹
        bool bUseDeltaCompression;  // ä½¿ç”¨å¢é‡å‹ç¼©
        bool bUseBatching;          // ä½¿ç”¨æ‰¹å¤„ç†
        int32 MaxBatchSize;         // æœ€å¤§æ‰¹å¤„ç†å¤§å°
        float BatchTimeout;         // æ‰¹å¤„ç†è¶…æ—¶
    };
    
    /**
     * æ™ºèƒ½å‘é€è¯ç¼€æ•°æ®
     */
    UFUNCTION(BlueprintCallable)
    void IntelligentSendAffixData(const FSagaActiveAffixInfo& AffixInfo, 
                                 ENetworkPriority Priority = ENetworkPriority::Medium);
    
    /**
     * è‡ªé€‚åº”å¸¦å®½ç®¡ç†
     */
    UFUNCTION(BlueprintCallable)
    void AdaptiveBandwidthManagement();
    
    /**
     * ç½‘ç»œè´¨é‡è¯„ä¼°
     */
    UFUNCTION(BlueprintCallable)
    float AssessNetworkQuality();
    
private:
    // ç½‘ç»œç»Ÿè®¡æ•°æ®
    USTRUCT()
    struct FNetworkStats {
        float AverageLatency = 0.0f;
        float PacketLoss = 0.0f;
        float Bandwidth = 0.0f;
        float Jitter = 0.0f;
        FDateTime LastUpdate;
    };
    
    UPROPERTY()
    FNetworkStats CurrentNetworkStats;
    
    // æ‰¹å¤„ç†é˜Ÿåˆ—
    UPROPERTY()
    TMap<ENetworkPriority, TArray<FSagaActiveAffixInfo>> BatchQueues;
    
    // åŒæ­¥é…ç½®æ˜ å°„
    UPROPERTY()
    TMap<ENetworkPriority, FIntelligentSyncConfig> SyncConfigs;
    
    /**
     * é€‰æ‹©æœ€ä¼˜åŒæ­¥ç­–ç•¥
     */
    FIntelligentSyncConfig SelectOptimalSyncStrategy(ENetworkPriority Priority);
    
    /**
     * åŠ¨æ€è°ƒæ•´åŒæ­¥å‚æ•°
     */
    void DynamicAdjustSyncParameters();
    
    /**
     * å¤„ç†æ‰¹é‡å‘é€
     */
    void ProcessBatchedSending(ENetworkPriority Priority);
    
    /**
     * ç½‘ç»œæ‹¥å¡æ§åˆ¶
     */
    void NetworkCongestionControl();
};
```

---

## å®æ–½è·¯çº¿å›¾æ›´æ–°

### ç¬¬ä¸€é˜¶æ®µï¼šåŠ¨ä½œæ¸¸æˆæ ¸å¿ƒä¼˜åŒ– (3å‘¨)

```mermaid
gantt
    title ç¬¬ä¸€é˜¶æ®µï¼šåŠ¨ä½œæ¸¸æˆæ ¸å¿ƒä¼˜åŒ–
    dateFormat  YYYY-MM-DD
    
    section å®æ—¶å“åº”ç³»ç»Ÿ
    å¿«é€Ÿå“åº”æ¶æ„              :response, 2025-07-17, 4d
    é¢„æµ‹ç³»ç»Ÿå®ç°              :prediction, after response, 3d
    å³æ—¶åé¦ˆæœºåˆ¶              :feedback, after prediction, 3d
    
    section æ€§èƒ½ä¼˜åŒ–
    å†…å­˜æ± åŒ–ç®¡ç†              :memory, after feedback, 3d
    é¢„è®¡ç®—ç¼“å­˜ç³»ç»Ÿ            :cache, after memory, 2d
    æ‰¹å¤„ç†ä¼˜åŒ–                :batch, after cache, 2d
    
    section ä½“éªŒå¢å¼º
    å¤šå±‚æ¬¡åé¦ˆç³»ç»Ÿ            :experience, after batch, 3d
    æš´çˆ½æ—¶åˆ»ç®¡ç†å™¨            :epic, after experience, 2d
    åŠ¨æ€VFXç³»ç»Ÿ               :vfx, after epic, 3d
```

### ç¬¬äºŒé˜¶æ®µï¼šæ™ºèƒ½ç³»ç»Ÿå’Œå¹³è¡¡ (3å‘¨)

```mermaid
gantt
    title ç¬¬äºŒé˜¶æ®µï¼šæ™ºèƒ½ç³»ç»Ÿå’Œå¹³è¡¡
    dateFormat  YYYY-MM-DD
    
    section æ™ºèƒ½ç®¡ç†
    è‡ªé€‚åº”å¹³è¡¡ç³»ç»Ÿ            :balance, 2025-08-07, 4d
    å¤æ‚åº¦ç®¡ç†å™¨              :complexity, after balance, 3d
    AIæ¨èå¼•æ“                :ai, after complexity, 4d
    
    section ç½‘ç»œä¼˜åŒ–
    æ™ºèƒ½ç½‘ç»œåŒæ­¥              :network, after ai, 3d
    é¢„æµ‹éªŒè¯ç³»ç»Ÿ              :validation, after network, 2d
    åä½œå¼Šæœºåˆ¶                :anticheat, after validation, 2d
    
    section ç¤¾åŒºåŠŸèƒ½
    æ„å»ºåˆ†äº«ç³»ç»Ÿ              :sharing, after anticheat, 4d
    æŒ‘æˆ˜ç³»ç»Ÿ                  :challenge, after sharing, 2d
```

### ç¬¬ä¸‰é˜¶æ®µï¼šç¤¾åŒºå’Œæ‰©å±• (2å‘¨)

```mermaid
gantt
    title ç¬¬ä¸‰é˜¶æ®µï¼šç¤¾åŒºå’Œæ‰©å±•
    dateFormat  YYYY-MM-DD
    
    section ç¤¾åŒºå¹³å°
    æ„å»ºç¼–è¾‘å™¨                :editor, 2025-08-28, 3d
    ç¤¾åŒºæœç´¢å¼•æ“              :search, after editor, 2d
    è¯„åˆ†å’Œè¯„è®ºç³»ç»Ÿ            :rating, after search, 2d
    
    section åˆ›ä½œå·¥å…·
    æ•ˆæœæ¨¡æ‹Ÿå™¨                :simulator, after rating, 3d
    æ€§èƒ½åˆ†æå™¨                :analyzer, after simulator, 2d
    
    section æœ€ç»ˆé›†æˆ
    å…¨ç³»ç»Ÿé›†æˆæµ‹è¯•            :integration, after analyzer, 2d
    æ€§èƒ½åŸºå‡†æµ‹è¯•              :benchmark, after integration, 1d
```

---

## æ€»ç»“

### v3.0æ ¸å¿ƒåˆ›æ–°ç‚¹

1. **åŠ¨ä½œæ¸¸æˆç‰¹åŒ–**: é’ˆå¯¹åŠ¨ä½œæ¸¸æˆçš„å“åº”é€Ÿåº¦å’Œä½“éªŒéœ€æ±‚å…¨é¢ä¼˜åŒ–
2. **æ™ºèƒ½å¹³è¡¡ç³»ç»Ÿ**: AIé©±åŠ¨çš„è‡ªé€‚åº”å¹³è¡¡å’Œå¤æ‚åº¦ç®¡ç†
3. **æè‡´æ€§èƒ½**: æ¯«ç§’çº§å“åº”å’Œé¢„æµ‹ç³»ç»Ÿ
4. **ç¤¾åŒºé©±åŠ¨**: å®Œæ•´çš„åˆ›ä½œã€åˆ†äº«ã€æŒ‘æˆ˜ç”Ÿæ€
5. **æ·±åº¦åé¦ˆ**: å¤šå±‚æ¬¡çš„è§†è§‰ã€éŸ³é¢‘ã€è§¦è§‰åé¦ˆç³»ç»Ÿ

### æŠ€æœ¯ä¼˜åŠ¿

- **é›¶å»¶è¿Ÿä½“éªŒ**: é€šè¿‡é¢„æµ‹ç³»ç»Ÿå®ç°16mså†…çš„å“åº”
- **æ™ºèƒ½é€‚åº”**: AIé©±åŠ¨çš„ä¸ªæ€§åŒ–æ¨èå’Œéš¾åº¦è°ƒæ•´
- **ç¤¾åŒºç”Ÿæ€**: å®Œæ•´çš„UGCåˆ›ä½œå’Œåˆ†äº«å¹³å°
- **æ‰©å±•æ€§**: æ¨¡å—åŒ–è®¾è®¡æ”¯æŒæœªæ¥åŠŸèƒ½æ‰©å±•
- **æ€§èƒ½å“è¶Š**: å…¨æ–¹ä½ä¼˜åŒ–ç¡®ä¿æµç•…è¿è¡Œ

### å®æ–½ä»·å€¼

v3.0ç‰ˆæœ¬å°†SagaStatsè¯ç¼€ç³»ç»Ÿä»æŠ€æœ¯æ¡†æ¶å‡çº§ä¸º**å®Œæ•´çš„åŠ¨ä½œæ¸¸æˆåˆ›ä½œå¹³å°**ï¼Œä¸ºç©å®¶æä¾›ï¼š

- **æ— é™åˆ›æ„ç©ºé—´**: é€šè¿‡è¯ç¼€ç»„åˆåˆ›é€ ç‹¬ç‰¹ç©æ³•
- **å³æ—¶æ»¡è¶³æ„Ÿ**: æ¯«ç§’çº§å“åº”å’Œæš´çˆ½æ—¶åˆ»è®¾è®¡
- **æŒç»­æŒ‘æˆ˜**: æ™ºèƒ½æ¨èå’Œç¤¾åŒºæŒ‘æˆ˜ä¿æŒæ–°é²œæ„Ÿ
- **ç¤¾äº¤ä½“éªŒ**: æ„å»ºåˆ†äº«å’Œåä½œåˆ›ä½œå¢å¼ºç¤¾åŒºè¿æ¥

è¿™ä¸ªæ¶æ„è®¾è®¡å……åˆ†ä½“ç°äº†**ä»äº§å“åˆ°å¹³å°**çš„è¿›åŒ–ï¼Œä¸ºåŠ¨ä½œæ¸¸æˆçš„è¯ç¼€ç³»ç»Ÿè®¾ç«‹äº†æ–°çš„è¡Œä¸šæ ‡å‡†ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: v3.0  
**æœ€åæ›´æ–°**: 2025-07-17  
**æ–‡æ¡£ä½œè€…**: ZhangJinming  
**åŸºäºæ–‡æ¡£**: åŠ¨ä½œæ¸¸æˆè¯ç¼€ç³»ç»Ÿè®¾è®¡æŒ‡å—.md  

---

*v3.0ç‰ˆæœ¬ä¸“ä¸ºåŠ¨ä½œæ¸¸æˆä¼˜åŒ–ï¼Œå®ç°äº†ä»æŠ€æœ¯æ¶æ„åˆ°ç©å®¶ä½“éªŒçš„å…¨é¢å‡çº§ï¼Œä¸ºSagaStatsé¡¹ç›®æä¾›äº†é¢å‘æœªæ¥çš„æŠ€æœ¯åŸºç¡€ã€‚*